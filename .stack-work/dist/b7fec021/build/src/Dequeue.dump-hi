
==================== FINAL INTERFACE ====================
2017-01-23 23:49:05.9291738 UTC

interface haskell-project-0.1.0.0-40Qus2qNav6FY2bGilXhPo:Dequeue 8001
  interface hash: 3439505982eb7cdade242d14e6d93f79
  ABI hash: 56032de13ff670e6b7c331d11042cf60
  export-list hash: 0ef5986a949cf27e577803e312e39e86
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 53494c7b8494714fedca6d8aca6be677
  sig of: Nothing
  used TH splices: False
  where
exports:
  Dequeue.emptyDEQ
  Dequeue.extractDEQ
  Dequeue.firstDEQ
  Dequeue.fromListDEQ
  Dequeue.isEmptyDEQ
  Dequeue.lastDEQ
  Dequeue.lengthDEQ
  Dequeue.popBackDEQ
  Dequeue.popfrontDEQ
  Dequeue.pushBackDEQ
  Dequeue.pushfrontDEQ
  Dequeue.takeBackDEQ
  Dequeue.takefrontDEQ
  Dequeue.toListDEQ
  Dequeue.Dequeue
module dependencies: List
package dependencies: base-4.9.0.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
import  -/  base-4.9.0.0:Data.Foldable 3cbed01c922be29649c33015287c82ca
import  -/  base-4.9.0.0:Data.Maybe 086a84053ef7f7810663b5f03b7ec3f7
import  -/  base-4.9.0.0:Data.Tuple 84c2bcc75b7a239341ae2f88cce9d8d7
import  -/  base-4.9.0.0:GHC.Base dd8044a8d640eee51828c17c476a6ba7
import  -/  base-4.9.0.0:GHC.List 47d436dfb7454bb1883fb4d943e3f389
import  -/  base-4.9.0.0:GHC.Num f0aed3315b3ed1b330b71fc4148a5581
import  -/  base-4.9.0.0:GHC.Real 011de9ca3282ad24a84e4e15f974f98e
import  -/  base-4.9.0.0:GHC.Show 0b5845243cb2ec62b57dd6963d276ec6
import  -/  base-4.9.0.0:Prelude 2d9cd8b0ec3d728f62b734df888d2e34
import  -/  ghc-prim-0.5.0.0:GHC.Classes 16d48e012d23eaef9bca91ccdd572c02
import  -/  List 930c35e7a085113987b50513ecd08b75
  exports: 03bfaa8f0a85c05a536d1d3a31b53baa
  safeHead f3c97f1b0ab7e697b542a441cf0427de
4ec5b438b8fe601865e6401afdee94d7
  $fShowDequeue ::
    GHC.Show.Show a => GHC.Show.Show (Dequeue.Dequeue a)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,A,C(U))>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Dequeue.Dequeue a)
                  (Dequeue.$fShowDequeue_$cshowsPrec @ a $dShow)
                  (Dequeue.$fShowDequeue_$cshow @ a $dShow)
                  (Dequeue.$fShowDequeue_$cshowList @ a $dShow) -}
b82b3bf50ab444f0491c8f371d256486
  $fShowDequeue1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
c25eb45363a329639a3b84c33cada2ea
  $fShowDequeue2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "MkDequeue {"#) -}
4d4b96b412c955feb9215ffc8ceb646d
  $fShowDequeue3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
64916deb82dcbefe2cb9dacebbb49c24
  $fShowDequeue4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "rlength = "#) -}
6db8b88b5d3c5ccb27c628af6c7f3c6f
  $fShowDequeue5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "r = "#) -}
adc61611f5613b1172227e6c915dcfa4
  $fShowDequeue6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "flength = "#) -}
d7f8c89094cba9c68f63a92a102ed689
  $fShowDequeue7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
9b4fb1ef516718aa1a13b1a2a930af1a
  $fShowDequeue8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "f = "#) -}
4ec5b438b8fe601865e6401afdee94d7
  $fShowDequeue_$cshow ::
    GHC.Show.Show a => Dequeue.Dequeue a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(A,A,C(U))><S,1*U(U,U(U),U,U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dShow :: GHC.Show.Show a) (x :: Dequeue.Dequeue a) ->
                 Dequeue.$fShowDequeue_$cshowsPrec
                   @ a
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
4ec5b438b8fe601865e6401afdee94d7
  $fShowDequeue_$cshowList ::
    GHC.Show.Show a => [Dequeue.Dequeue a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(A,A,C(U))><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (eta :: [Dequeue.Dequeue a])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Dequeue.Dequeue a)
                   (Dequeue.$fShowDequeue_$cshowsPrec
                      @ a
                      $dShow
                      Dequeue.$fShowDequeue1)
                   eta
                   eta1) -}
4ec5b438b8fe601865e6401afdee94d7
  $fShowDequeue_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> Dequeue.Dequeue a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(A,A,C(U))><S(S),1*U(U)><S,1*U(U,U(U),U,U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Dequeue.Dequeue a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { Dequeue.MkDequeue ww3 ww4 ww5 ww6 ->
                 Dequeue.$w$cshowsPrec @ a w ww1 ww3 ww4 ww5 ww6 } }) -}
e95f79d9d5bd7bfbf19e133197ec5878
  $tc'MkDequeue :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5713294013613237861##
                   16093678824085733094##
                   Dequeue.$trModule
                   Dequeue.$tc'MkDequeue1) -}
ff898a7539412fcca47172e3b30fa0db
  $tc'MkDequeue1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'MkDequeue"#) -}
8102c53a74c238432f46315f921b8fe7
  $tcDequeue :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2882485447129026256##
                   7057200083405164888##
                   Dequeue.$trModule
                   Dequeue.$trModule1) -}
6c3186f2485055159a85aa842da661ff
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Dequeue.$trModule2
                   Dequeue.$trModule1) -}
3856658028a2e8b92a86702dea4ae929
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Dequeue"#) -}
ad9d7d99813e37ba0628d679b2880f59
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "haskell-project-0.1.0.0-40Qus2qNav6FY2bGilXhPo"#) -}
58b738ed6fed07437204a2812555dac6
  $w$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Prim.Int#
    -> [a] -> GHC.Types.Int -> [a] -> GHC.Types.Int -> GHC.Show.ShowS
  {- Arity: 6,
     Strictness: <L,U(A,A,C(U))><S,U><L,U><L,U(U)><L,U><L,U(U)>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: [a])
                   (ww2 :: GHC.Types.Int)
                   (ww3 :: [a])
                   (ww4 :: GHC.Types.Int) ->
                 let {
                   f1 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showList @ a w ww1
                 } in
                 let {
                   f2 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showList @ a w ww3
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Dequeue.$fShowDequeue8
                       (f1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             Dequeue.$fShowDequeue7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Dequeue.$fShowDequeue6
                                (case ww2 of ww5 { GHC.Types.I# ww6 ->
                                 case GHC.Show.$wshowSignedInt
                                        0#
                                        ww6
                                        (GHC.Base.++
                                           @ GHC.Types.Char
                                           Dequeue.$fShowDequeue7
                                           (GHC.Base.++
                                              @ GHC.Types.Char
                                              Dequeue.$fShowDequeue5
                                              (f2
                                                 (GHC.Base.++
                                                    @ GHC.Types.Char
                                                    Dequeue.$fShowDequeue7
                                                    (GHC.Base.++
                                                       @ GHC.Types.Char
                                                       Dequeue.$fShowDequeue4
                                                       (case ww4 of ww7 { GHC.Types.I# ww8 ->
                                                        case GHC.Show.$wshowSignedInt
                                                               0#
                                                               ww8
                                                               (GHC.Base.++
                                                                  @ GHC.Types.Char
                                                                  Dequeue.$fShowDequeue3
                                                                  x) of ww9 { (#,#) ww10 ww11 ->
                                                        GHC.Types.:
                                                          @ GHC.Types.Char
                                                          ww10
                                                          ww11 } })))))) of ww7 { (#,#) ww8 ww9 ->
                                 GHC.Types.: @ GHC.Types.Char ww8 ww9 } }))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Base.++ @ GHC.Types.Char Dequeue.$fShowDequeue2 (g x)
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Dequeue.$fShowDequeue2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 x))) }) -}
e6ddc6685fef3cfd46371094fdfe8649
  $wdequeue ::
    [a]
    -> GHC.Prim.Int#
    -> [a]
    -> GHC.Prim.Int#
    -> (# [a], GHC.Types.Int, [a], GHC.Types.Int #)
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><S,U><L,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: [a])
                   (ww :: GHC.Prim.Int#)
                   (w1 :: [a])
                   (ww1 :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># ww (GHC.Prim.+# (GHC.Prim.*# 3# ww1) 1#)) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.># ww1 (GHC.Prim.+# (GHC.Prim.*# 3# ww) 1#)) of wild1 {
                        GHC.Types.False -> (# w, GHC.Types.I# ww, w1, GHC.Types.I# ww1 #)
                        GHC.Types.True
                        -> let {
                             j :: GHC.Types.Int
                             = case GHC.Classes.divInt#
                                      (GHC.Prim.+# ww ww1)
                                      2# of ww4 { DEFAULT ->
                               GHC.Types.I# (GHC.Prim.-# (GHC.Prim.+# ww ww1) ww4) }
                           } in
                           (# GHC.Base.++
                                @ a
                                w
                                (case j of wild2 { GHC.Types.I# x ->
                                 case GHC.Prim.tagToEnum#
                                        @ GHC.Types.Bool
                                        (GHC.Prim.<=# x 0#) of wild3 {
                                   GHC.Types.False
                                   -> GHC.List.reverse1
                                        @ a
                                        (Dequeue.$wunsafeDrop3 @ a x w1)
                                        (GHC.Types.[] @ a)
                                   GHC.Types.True
                                   -> GHC.List.reverse1 @ a w1 (GHC.Types.[] @ a) } }),
                              GHC.Types.I# ww,
                              case j of wild2 { GHC.Types.I# y ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.<# 0# y) of wild3 {
                                GHC.Types.False -> GHC.Types.[] @ a
                                GHC.Types.True -> GHC.List.$wunsafeTake @ a y w1 } },
                              GHC.Types.I# ww1 #) }
                   GHC.Types.True
                   -> let {
                        i :: GHC.Types.Int
                        = case GHC.Classes.divInt#
                                 (GHC.Prim.+# ww ww1)
                                 2# of ww4 { DEFAULT ->
                          GHC.Types.I# ww4 }
                      } in
                      (# case i of wild1 { GHC.Types.I# y ->
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<# 0# y) of wild2 {
                           GHC.Types.False -> GHC.Types.[] @ a
                           GHC.Types.True -> GHC.List.$wunsafeTake @ a y w } },
                         i,
                         GHC.Base.++
                           @ a
                           w1
                           (case i of wild1 { GHC.Types.I# x ->
                            case GHC.Prim.tagToEnum#
                                   @ GHC.Types.Bool
                                   (GHC.Prim.<=# x 0#) of wild2 {
                              GHC.Types.False
                              -> GHC.List.reverse1
                                   @ a
                                   (Dequeue.$wunsafeDrop2 @ a x w)
                                   (GHC.Types.[] @ a)
                              GHC.Types.True -> GHC.List.reverse1 @ a w (GHC.Types.[] @ a) } }),
                         case i of wild1 { GHC.Types.I# y ->
                         GHC.Types.I# (GHC.Prim.-# (GHC.Prim.+# ww ww1) y) } #) }) -}
97e68c3c1ea278d898a9888802d7ce3d
  $wfromListDEQ ::
    [a] -> (# [a], GHC.Types.Int, [a], GHC.Types.Int #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ @ a (w :: [a]) ->
                 case w of wild {
                   []
                   -> (# GHC.Types.[] @ a, Dequeue.$fShowDequeue1, GHC.Types.[] @ a,
                         Dequeue.$fShowDequeue1 #)
                   : ipv ipv1
                   -> let {
                        i :: GHC.Types.Int
                        = case GHC.List.$wlenAcc @ a wild 0# of ww2 { DEFAULT ->
                          GHC.Types.I# ww2 }
                      } in
                      let {
                        rlen :: GHC.Types.Int
                        = case i of ww { GHC.Types.I# ww1 ->
                          case GHC.Classes.divInt# ww1 2# of ww4 { DEFAULT ->
                          GHC.Types.I# ww4 } }
                      } in
                      let {
                        flen :: GHC.Types.Int
                        = case i of wild1 { GHC.Types.I# x ->
                          case rlen of wild2 { GHC.Types.I# y ->
                          GHC.Types.I# (GHC.Prim.-# x y) } }
                      } in
                      (# case flen of wild1 { GHC.Types.I# y ->
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<# 0# y) of wild2 {
                           GHC.Types.False -> GHC.Types.[] @ a
                           GHC.Types.True -> GHC.List.$wunsafeTake @ a y wild } },
                         flen,
                         case flen of wild1 { GHC.Types.I# x ->
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<=# x 0#) of wild2 {
                           GHC.Types.False
                           -> GHC.List.reverse1
                                @ a
                                (Dequeue.$wunsafeDrop @ a x wild)
                                (GHC.Types.[] @ a)
                           GHC.Types.True
                           -> GHC.List.reverse1 @ a wild (GHC.Types.[] @ a) } },
                         rlen #) }) -}
172a81a97e19ba255fdf0c637470f04d
  $wpopBackDEQ ::
    [a]
    -> GHC.Types.Int
    -> [a]
    -> GHC.Prim.Int#
    -> GHC.Base.Maybe (a, Dequeue.Dequeue a)
  {- Arity: 4, Strictness: <S,U><L,U(U)><L,U><S,U>, Inline: [0],
     Unfolding: (\ @ a
                   (ww :: [a])
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: [a])
                   (ww3 :: GHC.Prim.Int#) ->
                 let {
                   fail :: GHC.Prim.Void# -> GHC.Base.Maybe (a, Dequeue.Dequeue a)
                     {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds :: GHC.Prim.Void#)[OneShot] ->
                     case ww3 of wild {
                       DEFAULT
                       -> case ww1 of wild1 { GHC.Types.I# x ->
                          case x of wild2 {
                            DEFAULT
                            -> GHC.Base.Just
                                 @ (a, Dequeue.Dequeue a)
                                 (GHC.List.head @ a ww2,
                                  case Dequeue.$wdequeue
                                         @ a
                                         ww
                                         wild2
                                         (Dequeue.$wunsafeDrop1 @ a 1# ww2)
                                         (GHC.Prim.-# wild 1#) of ww4 { (#,,,#) ww5 ww6 ww7 ww8 ->
                                  Dequeue.MkDequeue @ a ww5 ww6 ww7 ww8 })
                            0#
                            -> GHC.Base.Just
                                 @ (a, Dequeue.Dequeue a)
                                 (GHC.List.head @ a ww2, Dequeue.emptyDEQ @ a) } }
                       0#
                       -> GHC.Base.Just
                            @ (a, Dequeue.Dequeue a)
                            (GHC.List.head @ a ww, Dequeue.emptyDEQ @ a) }
                 } in
                 case ww of wild {
                   []
                   -> case ww1 of wild1 { GHC.Types.I# ds ->
                      case ds of ds1 {
                        DEFAULT -> fail GHC.Prim.void#
                        0#
                        -> case ww2 of wild2 {
                             []
                             -> case ww3 of ds2 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  0# -> GHC.Base.Nothing @ (a, Dequeue.Dequeue a) }
                             : ipv ipv1 -> fail GHC.Prim.void# } } }
                   : ipv ipv1 -> fail GHC.Prim.void# }) -}
71a0bf71885587a03fa3b90b4ba22d2d
  $wpopfrontDEQ ::
    [a]
    -> GHC.Prim.Int#
    -> [a]
    -> GHC.Prim.Int#
    -> GHC.Base.Maybe (a, Dequeue.Dequeue a)
  {- Arity: 4, Strictness: <L,U><S,U><L,U><S,U>, Inline: [0],
     Unfolding: (\ @ a
                   (ww :: [a])
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: [a])
                   (ww3 :: GHC.Prim.Int#) ->
                 case GHC.Prim.+# ww3 ww1 of wild {
                   DEFAULT
                   -> case ww3 of wild1 {
                        DEFAULT
                        -> case ww1 of wild2 {
                             DEFAULT
                             -> GHC.Base.Just
                                  @ (a, Dequeue.Dequeue a)
                                  (GHC.List.head @ a ww,
                                   case Dequeue.$wdequeue
                                          @ a
                                          (Dequeue.$wunsafeDrop4 @ a 1# ww)
                                          (GHC.Prim.-# wild2 1#)
                                          ww2
                                          wild1 of ww4 { (#,,,#) ww5 ww6 ww7 ww8 ->
                                   Dequeue.MkDequeue @ a ww5 ww6 ww7 ww8 })
                             0#
                             -> GHC.Base.Just
                                  @ (a, Dequeue.Dequeue a)
                                  (GHC.List.head @ a ww2, Dequeue.emptyDEQ @ a) }
                        0#
                        -> GHC.Base.Just
                             @ (a, Dequeue.Dequeue a)
                             (GHC.List.head @ a ww, Dequeue.emptyDEQ @ a) }
                   0# -> GHC.Base.Nothing @ (a, Dequeue.Dequeue a) }) -}
287e01d3e7829a8bea4957d57fd1ac08
  $wtakeBackDEQ ::
    GHC.Prim.Int# -> [a] -> [a] -> GHC.Types.Int -> [a]
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U><L,1*U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ @ a
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: [a])
                   (ww2 :: [a])
                   (ww3 :: GHC.Types.Int) ->
                 let {
                   n :: [a]
                   = case ww3 of wild1 { GHC.Types.I# y ->
                     let {
                       x1 :: GHC.Prim.Int# = GHC.Prim.-# ww y
                     } in
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# x1 0#) of wild2 {
                       GHC.Types.False
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<# 0# x1) of wild {
                            GHC.Types.False -> GHC.Types.[] @ a
                            GHC.Types.True
                            -> GHC.List.$wunsafeTake
                                 @ a
                                 x1
                                 (GHC.List.reverse1 @ a ww1 (GHC.Types.[] @ a)) }
                       GHC.Types.True -> GHC.Types.[] @ a } }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# 0# ww) of wild {
                   GHC.Types.False -> n
                   GHC.Types.True
                   -> letrec {
                        $wgo :: [a] -> GHC.Prim.Int# -> [a]
                          {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0] -}
                        = \ (w :: [a]) (ww4 :: GHC.Prim.Int#) ->
                          case w of wild1 {
                            [] -> n
                            : y ys
                            -> case ww4 of ds1 {
                                 DEFAULT -> GHC.Types.: @ a y ($wgo ys (GHC.Prim.-# ds1 1#))
                                 1# -> GHC.Types.: @ a y n } }
                      } in
                      $wgo ww2 ww }) -}
102da73edcd80fe61fd33a2c4410844b
  $wtakefrontDEQ ::
    GHC.Prim.Int# -> [a] -> GHC.Types.Int -> [a] -> [a]
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U><L,1*U(U)><L,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: [a])
                   (ww2 :: GHC.Types.Int)
                   (ww3 :: [a]) ->
                 let {
                   n :: [a]
                   = case ww2 of wild1 { GHC.Types.I# y ->
                     let {
                       x1 :: GHC.Prim.Int# = GHC.Prim.-# ww y
                     } in
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# x1 0#) of wild2 {
                       GHC.Types.False
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<# 0# x1) of wild {
                            GHC.Types.False -> GHC.Types.[] @ a
                            GHC.Types.True
                            -> GHC.List.$wunsafeTake
                                 @ a
                                 x1
                                 (GHC.List.reverse1 @ a ww3 (GHC.Types.[] @ a)) }
                       GHC.Types.True -> GHC.Types.[] @ a } }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# 0# ww) of wild {
                   GHC.Types.False -> n
                   GHC.Types.True
                   -> letrec {
                        $wgo :: [a] -> GHC.Prim.Int# -> [a]
                          {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0] -}
                        = \ (w :: [a]) (ww4 :: GHC.Prim.Int#) ->
                          case w of wild1 {
                            [] -> n
                            : y ys
                            -> case ww4 of ds1 {
                                 DEFAULT -> GHC.Types.: @ a y ($wgo ys (GHC.Prim.-# ds1 1#))
                                 1# -> GHC.Types.: @ a y n } }
                      } in
                      $wgo ww1 ww }) -}
de77aa407daf6714e9dd1452e56e6350
  $wtoListDEQ :: [a] -> GHC.Prim.Int# -> [a] -> GHC.Prim.Int# -> [a]
  {- Arity: 4, HasNoCafRefs, Strictness: <L,1*U><S,U><L,1*U><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (ww :: [a])
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: [a])
                   (ww3 :: GHC.Prim.Int#) ->
                 case GHC.Prim.+# ww1 ww3 of wild {
                   DEFAULT
                   -> GHC.Base.++
                        @ a
                        ww
                        (GHC.List.reverse1 @ a ww2 (GHC.Types.[] @ a))
                   0# -> GHC.Types.[] @ a }) -}
94d9a0fbe4deb138d0589f4eb90b805f
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
090c571bd1acab37a29d793f8d73ac5b
  $wunsafeDrop1 :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
161fc87c69d99d4842152b8165f07004
  $wunsafeDrop2 :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
d7a20c25ce254ac18ba884809481d214
  $wunsafeDrop3 :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
ef8baba30e7bdbc5a50f79d9f34dafa7
  $wunsafeDrop4 :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
4ec5b438b8fe601865e6401afdee94d7
  data Dequeue a
    = MkDequeue {f :: [a],
                 flength :: GHC.Types.Int,
                 r :: [a],
                 rlength :: GHC.Types.Int}
fcabe6ea70f85f753f4fe7a23ee78599
  emptyDEQ :: Dequeue.Dequeue a
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (\ @ a ->
                 Dequeue.MkDequeue
                   @ a
                   (GHC.Types.[] @ a)
                   Dequeue.$fShowDequeue1
                   (GHC.Types.[] @ a)
                   Dequeue.$fShowDequeue1) -}
ae16e34a1d3b5c18de4ba473f6b469ce
  extractDEQ ::
    GHC.Base.Maybe (a, Dequeue.Dequeue a)
    -> (GHC.Base.Maybe a, Dequeue.Dequeue a)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: GHC.Base.Maybe (a, Dequeue.Dequeue a)) ->
                 case ds of wild {
                   GHC.Base.Nothing -> Dequeue.extractDEQ1 @ a
                   GHC.Base.Just ipv
                   -> (GHC.Base.Just
                         @ a
                         (Data.Tuple.fst @ a @ (Dequeue.Dequeue a) ipv),
                       Data.Tuple.snd @ a @ (Dequeue.Dequeue a) ipv) }) -}
1227585cf5611b284c4ce4862a1e2a5a
  extractDEQ1 :: (GHC.Base.Maybe a, Dequeue.Dequeue a)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (\ @ a ->
                 (GHC.Base.Nothing @ a, Dequeue.emptyDEQ @ a)) -}
0444d1b81b998df324231ebddcfb2069
  f :: Dequeue.Dequeue a -> [a]
  RecSel Left Dequeue.Dequeue
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLLL),1*U(1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Dequeue.Dequeue a) ->
                 case ds of wild { Dequeue.MkDequeue ds1 ds2 ds3 ds4 -> ds1 }) -}
543b86cfdd82d6b1ca107bb14b713d69
  firstDEQ :: Dequeue.Dequeue a -> GHC.Base.Maybe a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(S)LL),1*U(1*U,1*U(1*U),1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Dequeue.Dequeue a) ->
                 case ds of wild { Dequeue.MkDequeue f1 flen r1 rlen ->
                 case flen of wild1 { GHC.Types.I# x ->
                 case x of wild2 {
                   DEFAULT -> List.safeHead @ a f1
                   0# -> List.safeHead @ a r1 } } }) -}
cbdf7072b1154e152b802b1fc2c03cd9
  flength :: Dequeue.Dequeue a -> GHC.Types.Int
  RecSel Left Dequeue.Dequeue
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLL),1*U(A,1*U(U),A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Dequeue.Dequeue a) ->
                 case ds of wild { Dequeue.MkDequeue ds1 ds2 ds3 ds4 -> ds2 }) -}
f7dd49b464492332930c0eca3bd4b067
  fromListDEQ :: [a] -> Dequeue.Dequeue a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: [a]) ->
                 case Dequeue.$wfromListDEQ @ a w of ww { (#,,,#) ww1 ww2 ww3 ww4 ->
                 Dequeue.MkDequeue @ a ww1 ww2 ww3 ww4 }) -}
a739c457648dfbe9042425a3dc9192a5
  isEmptyDEQ :: Dequeue.Dequeue a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(S)LS(S)),1*U(A,1*U(U),A,1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Dequeue.Dequeue a) ->
                 case ds of wild { Dequeue.MkDequeue f1 flen r1 rlen ->
                 case flen of wild1 { GHC.Types.I# x ->
                 case rlen of wild2 { GHC.Types.I# y ->
                 case GHC.Prim.+# x y of wild3 {
                   DEFAULT -> GHC.Types.False 0# -> GHC.Types.True } } } }) -}
31c31cb221eb0812a85010594c79c875
  lastDEQ :: Dequeue.Dequeue a -> GHC.Base.Maybe a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLS(S)),1*U(1*U,A,1*U,1*U(1*U))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Dequeue.Dequeue a) ->
                 case ds of wild { Dequeue.MkDequeue f1 flen r1 rlen ->
                 case rlen of wild1 { GHC.Types.I# x ->
                 case x of wild2 {
                   DEFAULT -> List.safeHead @ a r1
                   0# -> List.safeHead @ a f1 } } }) -}
18368e877d02d85a16869a74ad61faf9
  lengthDEQ :: Dequeue.Dequeue a -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(S)LS(S)),1*U(A,1*U(U),A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Dequeue.Dequeue a) ->
                 case ds of wild { Dequeue.MkDequeue f1 flen r1 rlen ->
                 GHC.Num.$fNumInt_$c+ flen rlen }) -}
72fd97f21646806412f5742e875aec2c
  popBackDEQ ::
    Dequeue.Dequeue a -> GHC.Base.Maybe (a, Dequeue.Dequeue a)
  {- Arity: 1, Strictness: <S(SLLS(S)),1*U(U,U(U),U,U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Dequeue.Dequeue a) ->
                 case w of ww { Dequeue.MkDequeue ww1 ww2 ww3 ww4 ->
                 case ww4 of ww5 { GHC.Types.I# ww6 ->
                 Dequeue.$wpopBackDEQ @ a ww1 ww2 ww3 ww6 } }) -}
6b1c0d046e32cd97abdc98347628931d
  popfrontDEQ ::
    Dequeue.Dequeue a -> GHC.Base.Maybe (a, Dequeue.Dequeue a)
  {- Arity: 1, Strictness: <S(LS(S)LS(S)),1*U(U,1*U(U),U,1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Dequeue.Dequeue a) ->
                 case w of ww { Dequeue.MkDequeue ww1 ww2 ww3 ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 case ww4 of ww7 { GHC.Types.I# ww8 ->
                 Dequeue.$wpopfrontDEQ @ a ww1 ww6 ww3 ww8 } } }) -}
8eaa8fde0ab31dc70c500481e379d2f0
  pushBackDEQ :: Dequeue.Dequeue a -> a -> Dequeue.Dequeue a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS(S)LS(S)),1*U(U,1*U(U),U,1*U(U))><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: Dequeue.Dequeue a) (w1 :: a) ->
                 case w of ww { Dequeue.MkDequeue ww1 ww2 ww3 ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 case ww4 of ww7 { GHC.Types.I# ww8 ->
                 case Dequeue.$wdequeue
                        @ a
                        ww1
                        ww6
                        (GHC.Types.: @ a w1 ww3)
                        (GHC.Prim.+# ww8 1#) of ww9 { (#,,,#) ww10 ww11 ww12 ww13 ->
                 Dequeue.MkDequeue @ a ww10 ww11 ww12 ww13 } } } }) -}
f4b7d4df12e7e1967ecd32f37b19bf50
  pushfrontDEQ :: Dequeue.Dequeue a -> a -> Dequeue.Dequeue a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS(S)LS(S)),1*U(U,1*U(U),U,1*U(U))><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: Dequeue.Dequeue a) (w1 :: a) ->
                 case w of ww { Dequeue.MkDequeue ww1 ww2 ww3 ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 case ww4 of ww7 { GHC.Types.I# ww8 ->
                 case Dequeue.$wdequeue
                        @ a
                        (GHC.Types.: @ a w1 ww1)
                        (GHC.Prim.+# ww6 1#)
                        ww3
                        ww8 of ww9 { (#,,,#) ww10 ww11 ww12 ww13 ->
                 Dequeue.MkDequeue @ a ww10 ww11 ww12 ww13 } } } }) -}
c28edbb9a3aa711efe7425a81e2e2f4e
  r :: Dequeue.Dequeue a -> [a]
  RecSel Left Dequeue.Dequeue
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLSL),1*U(A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Dequeue.Dequeue a) ->
                 case ds of wild { Dequeue.MkDequeue ds1 ds2 ds3 ds4 -> ds3 }) -}
5456765c9ef07ab6ba824a25a16db4a2
  rlength :: Dequeue.Dequeue a -> GHC.Types.Int
  RecSel Left Dequeue.Dequeue
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLS),1*U(A,A,A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Dequeue.Dequeue a) ->
                 case ds of wild { Dequeue.MkDequeue ds1 ds2 ds3 ds4 -> ds4 }) -}
fd672c3a8f0031e740d0a84a77e58a0a
  takeBackDEQ :: GHC.Types.Int -> Dequeue.Dequeue a -> [a]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(U)><S,1*U(1*U,A,1*U,1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Types.Int) (w1 :: Dequeue.Dequeue a) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Dequeue.MkDequeue ww3 ww4 ww5 ww6 ->
                 Dequeue.$wtakeBackDEQ @ a ww1 ww3 ww5 ww6 } }) -}
f99d799bdfb8c4433ddc05c6804037ec
  takefrontDEQ :: GHC.Types.Int -> Dequeue.Dequeue a -> [a]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(U)><S,1*U(1*U,1*U(U),1*U,A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Types.Int) (w1 :: Dequeue.Dequeue a) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Dequeue.MkDequeue ww3 ww4 ww5 ww6 ->
                 Dequeue.$wtakefrontDEQ @ a ww1 ww3 ww4 ww5 } }) -}
88e992611e6bb829882f4e4b24039a54
  toListDEQ :: Dequeue.Dequeue a -> [a]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(S)LS(S)),1*U(1*U,1*U(U),1*U,1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Dequeue.Dequeue a) ->
                 case w of ww { Dequeue.MkDequeue ww1 ww2 ww3 ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 case ww4 of ww7 { GHC.Types.I# ww8 ->
                 Dequeue.$wtoListDEQ @ a ww1 ww6 ww3 ww8 } } }) -}
instance [safe] GHC.Show.Show [Dequeue.Dequeue]
  = Dequeue.$fShowDequeue
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

